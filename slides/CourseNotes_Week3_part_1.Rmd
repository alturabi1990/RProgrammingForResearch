---
title: "Exploring data #1"
header-includes:
   - \usepackage{hyperref}
   - \definecolor{links}{HTML}{2A1B81}
   - \hypersetup{colorlinks,linkcolor=,urlcolor=links}
output: 
  beamer_presentation:
    theme: "metropolis"
fontsize: 10pt
---

```{r echo = FALSE}
options(width = 50)
```

## Exploring data

- How to explore depends on data type / class
- Data exploration includes simple statistics (max, mean, min, standard deviation)
- Data exploration include plots

## Example data---Beijing air quality

```{r echo = FALSE, out.width = "4.5in"}
knitr::include_graphics("../figures/mission_china_pm.png")
```

Source: http://www.stateair.net/web/post/1/1.HTML

## Example data---Beijing air quality

```{r echo = FALSE, out.width = "4.5in"}
knitr::include_graphics("../figures/crazy_bad.png")
```

Source: https://foreignpolicy.com/2010/11/19/beijing-air-crazy-bad/

## Example data---Beijing air quality

Find out more: 

https://www.wired.com/2015/03/opinion-us-embassy-beijing-tweeted-clear-air/
https://www.theguardian.com/environment/blog/2010/nov/19/crazy-bad-beijing-air-pollution
https://www.sciencemag.org/news/2018/04/rooftop-sensors-us-embassies-are-warning-world-about-crazy-bad-air-pollution

## Example data---Beijing air quality

Download the data [here](https://raw.githubusercontent.com/geanders/RProgrammingForResearch/master/data/Beijing_2017_HourlyPM25.csv). 

Then you can read this data into your R session: 

```{r}
library("readr")
```
```{r echo = FALSE, message = FALSE}
beijing_pm_raw <- read_csv("../data/Beijing_2017_HourlyPM25.csv", 
                       skip = 3)
```
```{r eval = FALSE}
beijing_pm_raw <- read_csv("data/Beijing_2017_HourlyPM25.csv", 
                       skip = 3)
```

## Example data---Beijing air quality

```{r}
head(beijing_pm_raw, n = 3)
```

## Example data---Beijing air quality

Let's clean this up a bit: 

```{r message = FALSE}
library("dplyr")
beijing_pm <- beijing_pm_raw %>% 
  rename(sample_time = `Date (LST)`, 
         value = Value,
         qc = `QC Name`) %>% 
  select(sample_time, value, qc)
head(beijing_pm, n = 3)
```

## Example data---Beijing air quality

This code will add the AQI categories:

```{r}
beijing_pm <- beijing_pm %>% 
  mutate(aqi = cut(value, 
                   breaks = c(0, 50, 100, 150, 200, 
                              300, 500, Inf),
                   labels = c("Good", "Moderate",
                              "Unhealthy for Sensitive Groups",
                              "Unhealthy", "Very Unhealthy", 
                              "Hazardous", "Beyond Index")))
head(beijing_pm, n = 2)
```



# Data types and vector classes

## Data types and vector classes

Here are a few common vector classes in R:

Class        | Example
------------ | -------------
`character`  | "Chemistry", "Physics", "Mathematics"
`numeric`    | 10, 20, 30, 40
`factor`     | Male [underlying number: 1], Female [2]
`Date`       | "2010-01-01" [underlying number: 14,610]
`logical`    | TRUE, FALSE [underlying numbers: 1, 0]

## Numeric vectors

To explore numeric vectors, there are a few base R functions that 
are very helpful. For example:

Function  | Description
--------- | -----------------
`min()` | Minimum of values in the vector
`max()` | Maximum of values in the vector
`mean()` | Mean of values in the vector
`median()` | Median of values in the vector

## Simple statistic examples

All of these take, as the main argument, the vector(s) for which you want the
statistic. 

```{r}
mean(x = beijing_pm$value)
min(x = beijing_pm$value)
```

If there are missing values in the vector, you'll need to add an
option to say what to do when them (e.g., `na.rm` or `use="complete.obs"`---see
help files).

## Simple statistic examples

These functions require a **numeric vector** as input. 

Remember that you can pull a column from a dataframe as a vector using
either `$` or the `pluck` function from `purrr`. Therefore, you can use 
either of these calls to get the mean weight of the children in the
dataset: 

```{r}
mean(beijing_pm$value)

library("purrr")
beijing_pm %>% 
  pluck("value") %>% 
  mean()
```

## The `summarize` function

Within a "tidy" workflow, you can use the `summarize` function from the `dplyr`
package to create summary statistics for a dataframe. This function inputs a
dataframe and outputs a dataframe with the specified summary measures.

## The `summarize` function

The basic format for using `summarize` is:

```{r eval = FALSE}
## Generic code
summarize(dataframe, 
          summary_column_1 = function(existing_columns),
          summary_column_2 = function(existing_columns))
```

## The `summarize` function

As an example, to summarize the `beijing_pm` dataset to get the minimum, mean,
and maximum PM\textsubscript{2.5} concentrations, you could run:

```{r}
summarize(beijing_pm,
          min_pm = min(value),
          mean_pm = mean(value),
          max_pm = max(value))
```

Notice that the output is one row (since the summary was on ungrouped data),
with three columns (since we defined three summaries in the `summarize`
function).

## The `summarize` function

Because the first input to the `summarize` function is a dataframe, you can
"pipe into" a `summarize` call. For example, we could have written the code on
the previous slide as:

```{r eval = FALSE}
beijing_pm %>% 
  summarize(min_pm = min(value),
            mean_pm = mean(value),
            max_pm = max(value))
```

As another note, because the output from `summarize` is also a dataframe, we
could also "pipe into" another tidyverse function after running `summarize`.

<!-- ## The `summarize` function -->

<!-- There are some special functions that are particularly useful to use with -->
<!-- `summarize` and other functions from the `dplyr` package: -->

<!-- Function | Description -->
<!-- ---------------|------------- -->
<!-- `n()`          | Number of elements in a vector -->
<!-- `n_distinct()` | Number of unique elements in a vector -->
<!-- `first()`      | First value in a vector -->
<!-- `last()`       | Last value in a vector -->

<!-- ## The `summarize` function -->

<!-- For example, the following call would give you the total number of observations in the dataset, the number of distinct values of age measured across all children, the ID of the first child included in the dataset, and the weight of the last child included in the dataset:   -->

<!-- ```{r} -->
<!-- distinct_nepali %>% -->
<!--   summarize(n_children = n(),  -->
<!--             n_distinct_ages = n_distinct(age), -->
<!--             first_id = first(id), -->
<!--             last_weight = last(wt)) -->
<!-- ``` -->

<!-- ## Grouping and summarizing -->

<!-- Often, you'll want to get summaries of the data stratified by groups within the data. For example, in the `nepali` dataset, you may want to get summaries by sex or by whether the child was short or tall.  -->

<!-- To get grouped summaries of a dataframe, you can first use the `group_by` function from the `dplyr` package to "group" the dataset, and then when you run "summarize", it will be applied **by group** to the data.  -->

<!-- Your final output from summarize will be a dataframe with:  -->

<!-- - As many rows as there were unique groups in the grouping factor(s) -->
<!-- - As many columns as you have defined summaries in the `summarize` function (the generic code above would result in two columns), plus columns for each of the grouping factors -->

<!-- ## Grouping and summarizing -->

<!-- Without piping, the use of `group_by` and `summarize` looks like this: -->

<!-- ```{r eval = FALSE} -->
<!-- # Generic code -->
<!-- summarize(group_by(dataframe, -->
<!--                    grouping_factor_1, grouping_factor_2),  -->
<!--           summary_column_1 = function(existing_columns), -->
<!--           summary_column_2 = function(existing_columns))  -->

<!-- ``` -->

<!-- You can see that `group_by` is nested within the `summarize` call, because `group_by` must be applied to the dataframe before `summarize` is run if you want to get summaries by group.  -->

<!-- ## Grouping and summarizing -->

<!-- This call tends to look much cleaner if you use piping. With piping, the generic call looks like:  -->

<!-- ```{r eval = FALSE} -->
<!-- # Generic code -->
<!-- dataframe %>%  -->
<!--   group_by(grouping_factor_1, grouping_factor_2) %>%  -->
<!--   summarize(summary_column_1 = function(existing_columns), -->
<!--             summary_column_2 = function(existing_columns)) -->
<!-- ``` -->

<!-- ## Grouping and summarizing -->

<!-- For example, in the Nepali dataset, say you want to get summaries by sex. You want to get the total number of children in each group, the mean weight, and the ID of the first child. -->

<!-- You can run: -->

<!-- ```{r} -->
<!-- distinct_nepali %>% -->
<!--   group_by(sex) %>% -->
<!--   summarize(n_children = n(),  -->
<!--             mean_wt = mean(wt, na.rm = TRUE), -->
<!--             first_id = first(id)) -->
<!-- ``` -->

<!-- ## Grouping and summarizing -->

<!-- ```{r} -->
<!-- distinct_nepali %>% -->
<!--   group_by(sex) %>% -->
<!--   summarize(n_children = n(),  -->
<!--             mean_wt = mean(wt, na.rm = TRUE), -->
<!--             first_id = first(id)) -->
<!-- ``` -->

<!-- Notice that the output is a dataframe with two rows (since there were two groups in the grouping factor) and four columns (one for the grouping factor, plus one for each of the summaries defined in the `summarize` function). -->

<!-- ## Grouping and summarizing -->

<!-- You can group by more than one variable. For example, to get summaries within groups divided by both sex and whether the child is tall (> 100 cm) or not, you could run: -->

<!-- \small -->

<!-- ```{r} -->
<!-- distinct_nepali %>% -->
<!--   mutate(tall = ht > 100) %>% -->
<!--   filter(!is.na(tall)) %>%  -->
<!--   group_by(sex, tall) %>% -->
<!--   summarize(n_children = n(), -->
<!--             mean_wt = mean(wt, na.rm = TRUE)) -->
<!-- ``` -->


## Factors in R

Factor vectors are used in R for **categorical variables**, where more than 
one observation can have the same category.

```{r echo = FALSE, out.width="4.5in"}
knitr::include_graphics("../figures/how_r_stores_figures.jpg")
```

Factor variables have one or more **levels**. While you will always see a 
factor printed with its factor level labels, R "remembers" the variable
with each level assigned a number.

## Factors in R

In tibbles, factors will be noted with "fctr" under the column name. 
For example, look at the `aqi` column in the `beijing_pm` data:

```{r}
head(beijing_pm, n = 3)
```

## Factors in R

You can use the `levels` function to see the levels of a factor vector, as well
as the order those levels are recorded in R.

```{r}
levels(beijing_pm$aqi)
```

## Factors in R

To explore a factor vector, you'll often want to **count** the number of 
observations in each category. You can do that with two functions in the
`dplyr` package, `group_by` and `count`. 

Start with a dataframe that includes the factor variable as a column. 
First `group_by` the factor, then pipe the output of that into the `count`
function. 

This will create a new summary dataframe, with a row for each level of the
factor. A column called `n` will give the number of observations in the 
original data that had that level of the factor.

## Factors in R

You can **count** how many observations have each level of a factor.

```{r echo = FALSE, out.width="4.5in"}
knitr::include_graphics("../figures/counting_factor.jpg")
```

## Factors in R

```{r message = FALSE, warning = FALSE}
beijing_pm %>% 
  group_by(aqi) %>% 
  count()
```

## Factors in R

You can jointly explore multiple columns in a dataframe. 

For example, if one column is a factor and one is numeric, it can be
useful to explore values of the numeric column within each level of 
the factor column. 

For the Beijing data, you may want to find out the mean comcentration of
PM\textsubscript{2.5} within each AQI level.

## Factors in R

You can **summarize** a numeric column within levels of a factor column:

```{r echo = FALSE, out.width="4in", fig.align='center'}
knitr::include_graphics("../figures/factor_summarize.jpg")
```

## Factors in R

To do this, pipe the dataframe into `group_by` (where you can group by the
factor column) and then into `summarize`, where you can calculate summaries. 

```{r message = FALSE, warning = FALSE}
beijing_pm %>% 
  group_by(aqi) %>% 
  summarize(mean_pm = mean(value))
```


## Factors in R

You can create several summaries at once: 

```{r message = FALSE, warning = FALSE}
beijing_pm %>% 
  group_by(aqi) %>% 
  summarize(min_pm = min(value), 
            max_pm = max(value))
```

## Factors in R

As a note, there's a function called `n()` that you can use inside
summarize to replace `count`. For example, these two expressions
give the same output: 

```{r eval = FALSE}
beijing_pm %>% 
  group_by(aqi) %>% 
  count()

beijing_pm %>% 
  group_by(aqi) %>% 
  summarize(n = n())
```


## Factors in R

If a column is in a character class, but you'd like it to be a 
factor, you can use `as.factor`: 

```{r}
beijing_pm %>% 
  mutate(qc = as.factor(qc))
```

## In-course exercise

We'll take a break now to start the in-course exercise for this week (Sections
1 and 2 for Week 3).

# Data from R packages

## Data from R packages

So far we've covered two ways to get data into R:

1. From flat files (either on your computer or online)
2. From files like SAS and Excel

Many R packages come with their own data, which is very easy to load and use.

## Data from R packages

For example, the `faraway` package has a dataset called `worldcup` that you'll
use today. To load it, use the `data()` function once you've loaded the package
with the name of the dataset as its argument:

```{r}
library("faraway")
data("worldcup")
```

## Data from R packages

Unlike most data objects you'll work with, the data that comes with an R package
will often have its own help file. You can access this using the `?` operator:

```{r, eval = FALSE}
?worldcup
```

## Data from R packages

To find out all the datasets that are available in the packages you currently
have loaded, run `data()` without an option inside the parentheses:

```{r, eval = FALSE}
data()
```

To find out all of the datasets available within a certain package, run `data`
with the argument `package`:

```{r eval = FALSE}
data(package = "faraway")
```


As a note, you can similarly use `library()`, without the name of a package, to
list all of the packages you have installed that you could call with
`library()`:

```{r, eval = FALSE}
library()
```



# Dates in R

## `Date` class

A common task when changing or adding columns is to change the class of some of
the columns. This is especially common for dates, which will often be read in as
a character vector when reading data into R.

## `lubridate` package 

The `lubridate` package is helpful for working with vectors of dates or date-times.

You will see dates represented in many different ways. For example, October
might be included in data as "October", "Oct", or "10". Further, the way the
elements are separated can vary.

Computers are very literal, so this ambiguity can be confusing for them.

## `lubridate` package

The `lubridate` package has a number of functions for converting character
strings into dates (or date-times). To decide which one to use, you just need to
know the order of the elements of the date in the character string.

For example, here are some commonly-used `lubridate` functions:

`lubridate` function | Order of date elements
---------------------|-----------------------
`ymd`                | year-month-day
`dmy`                | day-month-year
`mdy_hm`             | month-day-year-hour-minute
`ymd_hms`            | year-month-day-hour-minute-second

(Remember, you can use `vignette("lubridate")` and `?lubridate` to get help with
the `lubridate` package.)

## `lubridate` package

In many cases you can use functions from the `lubridate` package to parse dates
pretty easily. \medskip

For example, if you have a character string with the date in the order of
*year-month-day*, you can use the `ymd` function from `lubridate` to convert the
character string to the `Date` class. For example:

```{r message = FALSE}
library("lubridate")
my_date <- ymd("2008-10-13")
class(my_date)
```

## `lubridate` package

The functions in `lubridate` are pretty good at working with different ways of
expressing date and time elements intelligently:

```{r}
mdy("10-31-2017")
dmy("31 October 2017")
```

## `lubridate` package

There are lubridate functions that can parse date-times, too:

```{r}
ymd_hms("2017/10/31--17:33:10")
mdy_hm("Oct. 31, 2017 5:33PM", tz = "MST")
```


## Converting to `Date` class

We can use the `mdy_hms` function from `lubridate` to convert the `sample_time`
column in the `beijing_pm` dataset to a date-time class ("POSIXct"):

```{r}
beijing_pm <- beijing_pm %>% 
  mutate(sample_time = mdy_hm(sample_time))

head(beijing_pm, 3)
```

## Converting to `Date` class

Once you have an object in a date or date-time class, you can do things like plot by
date, calculate the range of dates, and calculate the total number of days the
dataset covers:

```{r}
range(beijing_pm$sample_time)
diff(range(beijing_pm$sample_time))
```

## `lubridate` package

The `lubridate` package also includes functions to pull out certain elements of
a date. For example, we could use `wday` to create a new column with the weekday
of each show:

```{r}
beijing_pm <- mutate(beijing_pm, 
                     sample_weekday = wday(sample_time, 
                                           label = TRUE))
```
## `lubridate` package

```{r}
beijing_pm %>% 
  select(sample_time, sample_weekday) %>% 
  sample_n(size = 3)
```

## `lubridate` package

The `wday` function created an **ordered factor** ("ord" below the
column name in the tibble print-out). You can use this like other
factors. 

## `lubridate` package

```{r}
beijing_pm %>% 
  group_by(sample_weekday) %>% 
  summarize(mean_pm = mean(value))
```

## `lubridate` package

Other functions in `lubridate` for pulling elements from a date include: 

- `mday`: Day of the month
- `yday`: Day of the year
- `month`: Month
- `quarter`: Fiscal quarter
- `year`: Year

# Logical operators, vectors, and expressions

## Logical operators, vectors, and expressions

**Logical expressions** are operators that conduct a logical test based on 
one or more vectors, while logical expressions are the full R expressions 
that use these operators to conduct the test. The output is a **logical vector**. 

```{r echo = FALSE, out.width="4.5in"}
knitr::include_graphics("../figures/logical_expression.jpg")
```

## Logical expressions

Last week, you learned some about logical expressions and how to use them with
the `filter` function. \medskip

You can use *logical vectors*, created with these expressions, for a lot data
exploration tasks. We'll review them and add some more details this week.

## Logical vectors

A logical expression outputs a *logical vector*. This logical vector will be the
same length as the original vector tested by the logical statement:

```{r}
length(beijing_pm$value)
length(beijing_pm$value > 500)
```

## Logical vectors

Each element of the logical vector can only have one of three values (`TRUE`,
`FALSE`, `NA`). The logical vector will have the value `TRUE` at any position
where the original vector met the logical condition you tested, and `FALSE`
anywhere else:

```{r}
head(beijing_pm$value)
head(beijing_pm$value > 500)
```

## Logical vectors

Because the logical vector is the same length as the vector it's testing, you
can add logical vectors to dataframes with `mutate`:

```{r}
beijing_pm <- beijing_pm %>% 
  mutate(beyond_index = value > 500)
```

## Logical vectors

```{r}
beijing_pm %>% 
  select(sample_time, value, beyond_index)
```


## Logical vectors

As another example, you could add a column that is a logical vector of whether
a day was in the "heating season", which usually ends on March 15 each year:

```{r}
beijing_pm <- beijing_pm %>% 
  mutate(heating = sample_time < ymd("2017-03-15")) 
```

## Common logical and relational operators in R

The **bang operator** (`!`) negates (flips) a logical expression:

```{r}
c(1, 2, 3) == c(1, 2, 5)
!(c(1, 2, 3) == c(1, 2, 5))
```

```{r}
is.na(c(1, 2,  NA))
!is.na(c(1, 2, NA))
```

## Common logical and relational operators in R

The `%in%` operator will check each element of a 
vector to see if it's a value that is included in a second 
vector. 

In this case, the two vectors don't have to have 
the same length: 

```{r}
c(1, 2, 3) %in% c(1, 5)
```

This logical expressions is asking *Is the first element of the first vector, 1,
in the set given by the second vector, 1 and 5? Is the second element of the
first vector, 2, in the set given by the second vector? Etc.*

## Logical vectors

You can do a few cool things now with this vector. For example, you can use it
with the `filter` function to pull out just the rows where `heating` is `TRUE`:

```{r}
beijing_pm %>% 
  filter(heating) %>% 
  slice(1:3)
```

## Logical vectors

Or, with `!`, just the rows where `heating` is `FALSE`:

```{r}
beijing_pm %>% 
  filter(!heating) %>% 
  slice(1:3)
```

## Logical vectors

All of the values in a logical vector are saved, at a deeper level, with a
number. Values of `TRUE` are saved as 1 and values of `FALSE` are saved as 0.

```{r echo = FALSE, out.width="4.5in"}
knitr::include_graphics("../figures/how_r_saves_logical_vector.jpg")
```

## Logical vectors

```{r}
head(beijing_pm$beyond_index)
```

```{r}
head(as.numeric(beijing_pm$beyond_index))
```


## Logical vectors

Therefore, you can use `sum()` to get the sum of all values in a vector. Because
logical vector values are linked with numerical values of 0 or 1, you can use
`sum()` to find out how many males and females are in the dataset:

```{r}
sum(beijing_pm$beyond_index)
sum(!beijing_pm$beyond_index)
```

## In-course exercise

We'll take a break now to start the in-course exercise for this week (Section
3 for Week 3).


# Tidyverse and cheatsheets

## The "tidyverse"

So far, we have used a number of packages that are part of the *tidyverse*. The
tidyverse is a collection of recent and developing packages for R, many written
by Hadley Wickham. \medskip

```{r echo = FALSE, out.width = "0.6\\textwidth", fig.align = "center"}
knitr::include_graphics("../figures/tidyverse_hexbin.jpeg")
```


## The "tidyverse"

```{r echo = FALSE, out.width = "0.7\\textwidth", fig.align = 'center'}
knitr::include_graphics("../figures/HadleyObama.png")
```

\begin{center}
"A giant among data nerds"
\end{center}

\footnotesize{
\url{https://priceonomics.com/hadley-wickham-the-man-who-revolutionized-r/}}

## Cheatsheets

RStudio has several very helpful **cheatsheets**. These are one-page sheets
(front and back) that cover many of the main functions for a certain topic or
task in R. These cheatsheets cover a lot of the main "tidyverse" functions.

You can access these directly from RStudio. Go to "Help" -> "Cheatsheets" and
select the cheatsheet on the topic of interest.

You can find even more of these cheatsheets at
https://www.rstudio.com/resources/cheatsheets/.

## Cheatsheets

```{r echo = FALSE, out.width = "0.9\\textwidth", fig.align = 'center'}
knitr::include_graphics("../figures/rstudio_cheatsheet.png")
```

## More reading / practice

If you would like more reading and practice on what we've covered so far on transforming data, see chapter 5 of the "R for Data Science" book suggested at the start of the course. 

As a reminder, that is available at: 

http://r4ds.had.co.nz

# Basic plotting

## Example data---Beijing air quality

Let's read the Beijing data in and clean up the "-999" values: 

```{r}
library("readr")
```
```{r echo = FALSE, message = FALSE}
beijing_pm_raw <- read_csv("../data/Beijing_2017_HourlyPM25.csv", 
                       skip = 3, na = "-999")
```
```{r eval = FALSE}
beijing_pm_raw <- read_csv("data/Beijing_2017_HourlyPM25.csv", 
                       skip = 3, na = "-999")
```

## Example data---Beijing air quality

Clean up as before:

\footnotesize

```{r}
beijing_pm <- beijing_pm_raw %>% 
  rename(sample_time = `Date (LST)`, 
         value = Value,
         qc = `QC Name`) %>% 
  select(sample_time, value, qc) %>% 
  mutate(aqi = cut(value, 
                   breaks = c(0, 50, 100, 150, 200, 
                              300, 500, Inf),
                   labels = c("Good", "Moderate",
                              "Unhealthy for Sensitive Groups",
                              "Unhealthy", "Very Unhealthy", 
                              "Hazardous", "Beyond Index"))) %>% 
  mutate(sample_time = mdy_hm(sample_time)) %>% 
  mutate(heating = sample_time < mdy("03/15/2017"))
```

# Plots 

## Plots to explore data

Plots can be invaluable in exploring your data. \medskip

Today, we will focus on **useful**, rather than **attractive** graphs, since we
are focusing on exploring rather than presenting data. \medskip

Next lecture, we will talk more about customization, to help you make more
attractive plots that would go into final reports. \medskip

## `ggplot` conventions

Here, we'll be using functions from the `ggplot2` library, so you'll need to install that package:

```{r}
library("ggplot2")
```

The basic steps behind creating a plot with `ggplot2` are:

1. Create an object of the `ggplot` class, typically specifying the **data** to
be shown in the plot;
2. Add on (using `+`) one or more **geoms**, specifying the **aesthetics** for
each; and
3. Add on (using `+`) other elements to create and customize the plot (e.g., add
layers to customize scales or themes or to add facets).

*Note*: To avoid errors, end lines with `+`, don't start lines with it. 

## Plot data

The `ggplot` function requires you to input a dataframe with the data you will
plot. All the columns in that dataframe can be mapped to specific aesthetics
within the plot.

```{r}
beijing_pm %>% 
  slice(1:3)
```

For example, if we input the `beijing_pm` dataframe, we would be able to create
a plot that shows each sample's sampling time on the x-axis,
PM\textsubscript{2.5} concentration on the y-axis, and AQI by the color of the
point.

## Plot aesthetics

**Aesthetics** are plotting elements that can show certain elements of the data.
\medskip

For example, you may want to create a scatterplot where color shows AQI,
x-position shows sampling time, and y-position shows PM\textsubscript{2.5}
concentration. \medskip

```{r echo = FALSE, warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 8, fig.height = 3.5}
beijing_pm %>%
  ggplot(aes(x = sample_time, y = value, 
             color = aqi)) + 
  geom_point() + 
  xlab("Sampling time") + ylab("PM2.5 concentration")
```

## Plot aesthetics

In the previous graph, the mapped aesthetics are color, x, and y. In the
`ggplot` code, all of these aesthetic mappings will be specified within an `aes`
call, which will be nested in another call in the `ggplot` pipeline. \medskip

Aesthetic       | `ggplot` abbreviation  | `beijing_pm` column
----------------|------------------------|-----------------
x-axis position | `x = `                 | `sample_time`
y-axis position | `y = `                 | `value`
color           | `color = `             | `aqi`

This is how these mappings will be specified in an `aes` call:

```{r eval = FALSE}
# Note: This code should not be run by itself. 
# It will eventually be nested in a ggplot call.
aes(x = sample_time, y = value, color = aqi)
```


## Plot aesthetics

Here are some common plot aesthetics you might want to specify: 

```{r echo = FALSE}
aes_vals <- data.frame(aes = c("`x`", "`y`", "`shape`",
                               "`color`", "`fill`", "`size`",
                               "`alpha`", "`linetype`"),
                       desc = c("Position on x-axis", 
                                "Position on y-axis", 
                                "Shape",
                                "Color of border of elements", 
                                "Color of inside of elements",
                                "Size", 
                                "Transparency (1: opaque; 0: transparent)",
                                "Type of line (e.g., solid, dashed)"))
knitr::kable(aes_vals, col.names = c("Code", "Description"))
```

## Geoms

You will add **geoms** that create the actual geometric objects on the plot. For
example, a scatterplot has "points" geoms, since each observation is displayed
as a point.

There are `geom_*` functions that can be used to add a variety of geoms. The
function to add a "points" geom is `geom_point`.

We just covered three plotting elements: 

- Data
- Aesthetics
- Geoms

These are three elements that you will almost always specify when using
`ggplot`, and they are sufficient to create a number of basic plots.

## Creating a ggplot object

You can create a scatterplot using `ggplot` using the following code format:

```{r, eval = FALSE}
## Generic code
ggplot(data = dataframe) + 
  geom_point(mapping = aes(x = column_1, y = column_2, 
                           color = column_3))
```

\small 
Notice that: 

1. The `ggplot` call specifies the **dataframe** with the data you want to plot
2. A **geom** is added using the appropriate `geom_*` function for a scatterplot
(`geom_point`).
3. The mappings between columns in the dataframe and **aesthetics** of the geom
is specified within an `aes` call in the `mapping` argument of the `geom_*`
function call.
4. The `aes` call includes mappings to two aesthetics that are required from the
`geom_point` geom (`x` and `y`) and one that is optional (`color`).

## Creating a ggplot object

Let's put these ideas together to write the code to create a plot for our
example data:

```{r warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 8, fig.height = 3.5}
  ggplot(data = beijing_pm) + 
  geom_point(mapping = aes(x = sample_time, y = value, 
                           color = aqi)) 
```

## Adding geoms

There are a number of different `geom_*` functions you can use to add geoms to a
plot. They are divided between geoms that directly map the data to an aesthetic
and those that show some summary or statistic of the data. \medskip

Some of the most common direct-mapping geoms are:

Geom(s)                     | Description
----------------------------|--------------
`geom_point`                | Points in 2-D (e.g. scatterplot)
`geom_line`, `geom_path`    | Connect observations with a line
`geom_abline`               | A line with a certain intercept and slope
`geom_hline`, `geom_vline`  | A horizontal or vertical line
`geom_rug`                  | A rug plot
`geom_label`, `geom_text`   | Text labels

## Creating a ggplot object

You can add several geoms to the same plot as layers:

```{r warning = FALSE, fig.align = "center", out.width = "0.6\\textwidth", message = FALSE, fig.width = 5, fig.height = 3}
  ggplot(data = beijing_pm) + 
  geom_point(mapping = aes(x = sample_time, y = value)) + 
  geom_line(mapping = aes(x = sample_time, y = value)) + 
  geom_rug(mapping = aes(x = sample_time, y = value)) 
```

## Creating a ggplot object

You may have noticed that all of these geoms use the same aesthetic mappings
(height to x-axis position, weight to y-axis position, and sex to color). To
save time, you can specify the aesthetic mappings in the first `ggplot` call.
These mappings will then be the default for any of the added geoms.

```{r eval = FALSE, warning = FALSE}
ggplot(data = beijing_pm,
       mapping = aes(x = sample_time, y = value)) + 
  geom_point() + 
  geom_line() + 
  geom_rug() 
```

## Creating a ggplot object

Because the first argument of the `ggplot` call is a dataframe, you can also
"pipe into" a `ggplot` call:

```{r eval = FALSE}
beijing_pm %>% 
  ggplot(aes(x = sample_time, y = value)) + 
  geom_point() + 
  geom_line() + 
  geom_rug() 
```

## In-course exercise

We'll take a break now to continue the in-course exercise for this week (Section 4).

## Plot aesthetics

Which aesthetics you must specify in the `aes` call depend on which geom you are
adding to the plot. \medskip

You can find out the aesthetics you can use for a geom in the "Aesthetics"
section of the geom's help file (e.g., `?geom_point`). \medskip

Required aesthetics are in bold in this section of the help file and optional
ones are not.

## Constant aesthetics

Instead of mapping an aesthetic to an element of your data, you can use a
constant value for the aesthetic. For example, you may want to make all the
points blue, rather than having color map to AQI:

```{r echo = FALSE, warning = FALSE, fig.align = "center", out.width = "0.6\\textwidth", message = FALSE, fig.width = 5, fig.height = 3}
beijing_pm %>%
  ggplot(aes(x = sample_time, y = value)) + 
  geom_point(color = "blue")
```

In this case, you can define that aesthetic as a constant for the geom,
**outside** of an `aes` statement.

## Constant aesthetics

For example, you may want to change the shape of the points in a scatterplot from their default shape, but not map them to a particular element of the data. \medskip

In R, you can specify point shape with a number. Here are the shapes that correspond to the numbers 1 to 25:

```{r echo = FALSE, out.width = "0.6\\textwidth", fig.width = 5, fig.height = 3, fig.align = "center"}
x <- rep(1:5, 5)
y <- rep(1:5, each = 5)
shape <- 1:25
to_plot <- tibble(x = x, y = y, shape = shape)
ggplot(to_plot, aes(x = x, y = y)) + 
  geom_point(shape = shape, size = 4, color = "black", fill = "red") + 
  geom_text(label = shape, nudge_x = -0.25) +
  xlim(c(0.5, 5.5)) + 
  theme_void() + 
  scale_y_reverse()
```

## Constant aesthetics

Here is an example of mapping point shape to a constant value other than the
default:

```{r warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 8, fig.height = 3.5}
ggplot(data = beijing_pm) + 
  geom_point(mapping = aes(x = sample_time, y = value,
                           color = aqi),
             shape = 9)
```

## Constant aesthetics

R has character names for different colors. For example: 

```{r echo = FALSE, out.width = "0.18\\textwidth", fig.width = 5, fig.height = 3, fig.align = "center"}
x <- rep(0, 6)
y <- 1:6
color <- c("blue", "blue4", "darkorchid", "deepskyblue2", 
           "steelblue1", "dodgerblue3")
to_plot <- data_frame(x = x, y = y, color = color)
ggplot(to_plot, aes(x = x, y = y)) + 
  geom_point(color = color, size = 2) + 
  geom_text(label = color, hjust = 0, nudge_x = 0.05) + 
  theme_void() + 
  xlim(c(-1, 1.5)) +
  scale_y_reverse()
```

Google "R colors" and search the images to find links to listings of different R colors.

## Constant aesthetics

Here is an example of mapping point shape and color to constant values other than the defaults:

```{r warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 7, fig.height = 3}
ggplot(data = beijing_pm) + 
  geom_point(mapping = aes(x = sample_time, y = value),
             shape = 9, 
             color = "darkorchid")
```

## Useful plot additions

There are also a number of elements that you can add onto a `ggplot` object using `+`. A few very frequently used ones are: 

```{r echo = FALSE}
plot_adds <- data.frame(add = c("`ggtitle`",
                                "`xlab`, `ylab`, `labs`",
                                "`xlim`, `ylim`",
                                "`expand_limits`"),
                        descrip = c("Plot title",
                                    "x- and y-axis labels",
                                    "Limits of x- and y-axis",
                                    "Include a value in a range"))
knitr::kable(plot_adds, col.names = c("Element", "Description"))
```

## Useful plot additions

```{r warning = FALSE, fig.align = "center", out.width = "0.6\\textwidth", message = FALSE, fig.width = 5, fig.height = 3}
ggplot(data = beijing_pm) + 
  geom_point(mapping = aes(x = sample_time, y = value)) + 
  labs(x = "Sampling Date and Time", 
       y = "PM2.5 Concentration") + 
  ggtitle("Measurements of PM2.5 in Beijing, China, 2017",
          subtitle = "Based on U.S. Embassy Monitor") 
```

## In-course exercise

We’ll take a break now to continue the in-course exercise for this week (Section 5 of Week 3).

## Adding geoms

There are a number of different `geom_*` functions you can use to add geoms to a plot. They are divided between geoms that directly map the data to an aesthetic and those that show some summary or statistic of the data. \medskip 

Some of the most common "statistical" geoms are:

Geom(s)                        | Description
-------------------------------|--------------
`geom_histogram`               | Show distribution in 1-D
`geom_hex`, `geom_density`     | Show distribution in 2-D
`geom_col`, `geom_bar`         | Create bar charts
`geom_boxplot`, `geom_dotplot` | Create boxplots and related plots
`geom_smooth`                  | Add a fitted line to a scatterplot

## Adding geoms

These "statistical" geoms all input the original data and perform some
calculations on that data to determine how to plot the final geom. Often, this
calculation involves some kind of summarization.

## Adding geoms

For example, the geom for a histogram (`geom_hist`) divides the data into an
evenly-sized set of "bins" and then calculates the number of points in each bin
to provide a visualization of how the data is distributed.

```{r echo = FALSE, out.width = "0.6\\textwidth", fig.align = "center"}
knitr::include_graphics("../figures/histogram_illustration.jpg")
```

## Adding geoms

To plot a histogram of PM_{2.5} concentrations in the Beijing data, run:

```{r warning = FALSE, fig.align = "center", out.width = "0.6\\textwidth", message = FALSE, fig.width = 5, fig.height = 3}
ggplot(data = beijing_pm) + 
  geom_histogram(aes(x = value))
```


## Histogram example

You can add some elements to the histogram, like `ggtitle`, and `labs`:

```{r, fig.width = 4, fig.height = 2.5, out.width="0.6\\textwidth", fig.align = "center", message = FALSE, warning = FALSE}
ggplot(beijing_pm, aes(x = value)) + 
  geom_histogram(fill = "lightblue", color = "black") + 
  ggtitle("PM2.5 Concentrations in Beijing") + 
  labs(x = "PM2.5 Concentration", y = "Number of samples") 
```

## Histogram example

`geom_histogram` also has its own special argument, `bins`. You can use this to change the number of bins that are used to make the histogram:

```{r, fig.width = 2.5, fig.height = 2, fig.align = "center", warning = FALSE, message = FALSE}
ggplot(beijing_pm, aes(x = value)) + 
  geom_histogram(bins = 100) 
```

## Bar chart

You can use the `geom_bar` geom to create a barchart:

```{r warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 7, fig.height = 2.5}
ggplot(beijing_pm, aes(x = aqi)) + 
  geom_bar()
```

## Bar chart

You can use the `geom_bar` geom to show counts for two factors by using `x` for
one and `fill` for the other:

```{r warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 7, fig.height = 2.5}
ggplot(beijing_pm, aes(x = aqi, fill = heating)) + 
  geom_bar()
```

## Bar chart

With the `geom_bar` geom, you can use the `position` argument to change how the
bars for different groups are shown (`"stack"`, `"dodge"`, `"fill"`):

```{r warning = FALSE, fig.align = "center", out.width = "0.9\\textwidth", message = FALSE, fig.width = 8, fig.height = 3}
ggplot(beijing_pm, aes(x = aqi, fill = heating)) + 
  geom_bar(position = "dodge")
```

## Boxplot example

To create a boxplot, you can use `geom_boxplot`: 

```{r, fig.height = 2, fig.width = 2, warning = FALSE, fig.align="center"}
ggplot(beijing_pm, aes(x = 1, y = value)) + 
  geom_boxplot() + 
  labs(x = "", y = "PM2.5 Concentration")
```

## Boxplot example

You can also do separate boxplots by a factor. In this case, you'll need to include two aesthetics (`x` and `y`) when you initialize the ggplot object. 

```{r, fig.height = 3.8, fig.width = 8, fig.align = "center", warning = FALSE, out.width = "\\textwidth"}
ggplot(beijing_pm, aes(x = aqi, y = value, group = aqi)) + 
  geom_boxplot() + 
  labs(x = "AQI Category", y = "PM2.5 Concentration")
```

## In-course exercise

We'll take a break now to finish the in-course exercise for this week (Section 6 of Week 3).
